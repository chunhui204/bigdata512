53c53
< #define ZV_ENABLE       0x0100
---
> 
69,103c69,104
<  ScreenPtr   pScreen,
<  ScrnInfoPtr pScreenInfo,
<  ATIPtr      pATI
<  )
< {
<   XF86VideoAdaptorPtr *ppAdaptors, *ppNewAdaptors=NULL;
<   XF86VideoAdaptorPtr newAdaptor = NULL;
<   int                 nAdaptors;
<   Bool		result;
<   
<   if (!(pScreenInfo->memPhysBase = pATI->LinearBase))
<     return FALSE;
<   
<   if(pATI->pXAAInfo && pATI->pXAAInfo->FillSolidRects){
<     newAdaptor = ATISetupImageVideo(pScreen);
<   }
<   
<   pScreenInfo->fbOffset = 0;
<   
<   nAdaptors = xf86XVListGenericAdaptors(pScreenInfo, &ppAdaptors);
<   
<   if(newAdaptor) {
<     if(!nAdaptors) {
<       nAdaptors = 1;
<       ppAdaptors = &newAdaptor;
<     } else {
<       ppNewAdaptors =  /* need to free this someplace */
< 	xalloc((nAdaptors + 1) * sizeof(XF86VideoAdaptorPtr*));
<       if(ppNewAdaptors) {
< 	memcpy(ppNewAdaptors, ppAdaptors, nAdaptors *
< 	       sizeof(XF86VideoAdaptorPtr));
< 	ppNewAdaptors[nAdaptors] = newAdaptor;
< 	ppAdaptors = ppNewAdaptors;
< 	nAdaptors++;
<       }
---
>     ScreenPtr   pScreen,
>     ScrnInfoPtr pScreenInfo,
>     ATIPtr      pATI
> )
> {
>     XF86VideoAdaptorPtr *ppAdaptors, *ppNewAdaptors=NULL;
>     XF86VideoAdaptorPtr newAdaptor = NULL;
>     int                 nAdaptors;
>     Bool		result;
> 
>     if (!(pScreenInfo->memPhysBase = pATI->LinearBase))
>         return FALSE;
> 
>     if(pATI->pXAAInfo && pATI->pXAAInfo->FillSolidRects){
> 	newAdaptor = ATISetupImageVideo(pScreen);
>         }
> 
>     pScreenInfo->fbOffset = 0;
> 
>     nAdaptors = xf86XVListGenericAdaptors(pScreenInfo, &ppAdaptors);
> 
>     if(newAdaptor) {
> 	if(!nAdaptors) {
> 	    nAdaptors = 1;
> 	    ppAdaptors = &newAdaptor;
> 	} else {
> 	    ppNewAdaptors =  /* need to free this someplace */
> 		xalloc((nAdaptors + 1) * sizeof(XF86VideoAdaptorPtr*));
> 	    if(ppNewAdaptors) {
> 		memcpy(ppNewAdaptors, ppAdaptors, nAdaptors *
> 					sizeof(XF86VideoAdaptorPtr));
> 		ppNewAdaptors[nAdaptors] = newAdaptor;
> 		ppAdaptors = ppNewAdaptors;
> 		nAdaptors++;
> 	    }
> 	}
105,113c106,113
<   }
<   
<   if(nAdaptors)
<     result=xf86XVScreenInit(pScreen, ppAdaptors, nAdaptors);
<   else result=FALSE;
<   if(ppNewAdaptors)
<     xfree(ppNewAdaptors);
<   
<   return result;
---
> 
>     if(nAdaptors)
> 	    result=xf86XVScreenInit(pScreen, ppAdaptors, nAdaptors);
> 	    else result=FALSE;
>     if(ppNewAdaptors)
> 	xfree(ppNewAdaptors);
> 
>     return result;
197d196
<    Bool          zv_port;
284,286c283
<     { 12,"pal_60-svideo",		720, 288, { 1, 50 }},
<     { 13,"pal_zv", 		        720, 576, { 1, 1 }},
<     { 14,"ntsc_zv", 		        640, 480, { 1, 1 }}
---
>     { 12,"pal_60-svideo",		720, 288, { 1, 50 }}
304,306c301
<     { 12,"pal_60-svideo",		768, 288, { 1, 50 }},
<     { 13,"pal_zv", 		        720, 288, { 1, 1 }},
<     { 14,"ntsc_zv", 		        640, 240, { 1, 1 }}
---
>     { 12,"pal_60-svideo",		768, 288, { 1, 50 }}
424,461c419,456
<   ATIPtr   pATI      = ATIPTR(pScrn);
<   ATIPortPrivPtr pPriv = pATI->adaptor->pPortPrivates[0].ptr;
<   
<   /* this is done here because each time the server is reset these
<      could change.. Otherwise they remain constant */
<   
<   xvBrightness   = MAKE_ATOM("XV_BRIGHTNESS");
<   xvSaturation   = MAKE_ATOM("XV_SATURATION");
<   xvColor        = MAKE_ATOM("XV_COLOR");
<   xvContrast     = MAKE_ATOM("XV_CONTRAST");
<   xvColorKey     = MAKE_ATOM("XV_COLORKEY");
<   xvDoubleBuffer = MAKE_ATOM("XV_DOUBLE_BUFFER");
<   xvEncoding     = MAKE_ATOM("XV_ENCODING");
<   xvFrequency    = MAKE_ATOM("XV_FREQ");
<   xvTunerStatus  = MAKE_ATOM("XV_TUNER_STATUS");
<   xvVolume       = MAKE_ATOM("XV_VOLUME");
<   xvMute         = MAKE_ATOM("XV_MUTE");
<   xvHue          = MAKE_ATOM("XV_HUE");
<   xv_autopaint_colorkey = MAKE_ATOM("XV_AUTOPAINT_COLORKEY");
<   xv_set_defaults = MAKE_ATOM("XV_SET_DEFAULTS");
<   
<   ATIMach64WaitForFIFO(pATI, 14);
<   outf(OVERLAY_SCALE_CNTL, 0x80000000);
<   outf(OVERLAY_EXCLUSIVE_HORZ, 0);
<   outf(OVERLAY_EXCLUSIVE_VERT, 0);
<   outf(SCALER_H_COEFF0, 0x00002000);
<   outf(SCALER_H_COEFF1, 0x0D06200D);
<   outf(SCALER_H_COEFF2, 0x0D0A1C0D);
<   outf(SCALER_H_COEFF3, 0x0C0E1A0C);
<   outf(SCALER_H_COEFF4, 0x0C14140C);
<   outf(SCALER_COLOUR_CNTL, (pPriv->brightness & 0x7f) |
<        (pPriv->saturation << 8) |
<        (pPriv->saturation << 16));
<   outf(VIDEO_FORMAT, 0xB000B);
<   outf(OVERLAY_GRAPHICS_KEY_MSK, (1 << pScrn->depth) - 1);
<   outf(OVERLAY_GRAPHICS_KEY_CLR, pPriv->colorKey);
<   outf(OVERLAY_KEY_CNTL, 0x50);
<   outf(OVERLAY_TEST, 0);
---
>     ATIPtr   pATI      = ATIPTR(pScrn);
>     ATIPortPrivPtr pPriv = pATI->adaptor->pPortPrivates[0].ptr;
> 
>     /* this is done here because each time the server is reset these
>        could change.. Otherwise they remain constant */
> 
>     xvBrightness   = MAKE_ATOM("XV_BRIGHTNESS");
>     xvSaturation   = MAKE_ATOM("XV_SATURATION");
>     xvColor        = MAKE_ATOM("XV_COLOR");
>     xvContrast     = MAKE_ATOM("XV_CONTRAST");
>     xvColorKey     = MAKE_ATOM("XV_COLORKEY");
>     xvDoubleBuffer = MAKE_ATOM("XV_DOUBLE_BUFFER");
>     xvEncoding     = MAKE_ATOM("XV_ENCODING");
>     xvFrequency    = MAKE_ATOM("XV_FREQ");
>     xvTunerStatus  = MAKE_ATOM("XV_TUNER_STATUS");
>     xvVolume       = MAKE_ATOM("XV_VOLUME");
>     xvMute         = MAKE_ATOM("XV_MUTE");
>     xvHue          = MAKE_ATOM("XV_HUE");
>     xv_autopaint_colorkey = MAKE_ATOM("XV_AUTOPAINT_COLORKEY");
>     xv_set_defaults = MAKE_ATOM("XV_SET_DEFAULTS");
> 
>     ATIMach64WaitForFIFO(pATI, 14);
>     outf(OVERLAY_SCALE_CNTL, 0x80000000);
>     outf(OVERLAY_EXCLUSIVE_HORZ, 0);
>     outf(OVERLAY_EXCLUSIVE_VERT, 0);
>     outf(SCALER_H_COEFF0, 0x00002000);
>     outf(SCALER_H_COEFF1, 0x0D06200D);
>     outf(SCALER_H_COEFF2, 0x0D0A1C0D);
>     outf(SCALER_H_COEFF3, 0x0C0E1A0C);
>     outf(SCALER_H_COEFF4, 0x0C14140C);
>     outf(SCALER_COLOUR_CNTL, (pPriv->brightness & 0x7f) |
> 				 (pPriv->saturation << 8) |
> 				 (pPriv->saturation << 16));
>     outf(VIDEO_FORMAT, 0xB000B);
>     outf(OVERLAY_GRAPHICS_KEY_MSK, (1 << pScrn->depth) - 1);
>     outf(OVERLAY_GRAPHICS_KEY_CLR, pPriv->colorKey);
>     outf(OVERLAY_KEY_CNTL, 0x50);
>     outf(OVERLAY_TEST, 0);
1222d1216
< 
1246c1240,1241
< static void ATICheckZV( ScrnInfoPtr pScrn, ATIPtr pATI, ATIPortPrivPtr pPriv)
---
> static XF86VideoAdaptorPtr
> ATISetupImageVideo(ScreenPtr pScreen)
1247a1243,1246
>     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
>     ATIPtr pATI = ATIPTR(pScrn);
>     ATIPortPrivPtr pPriv;
>     XF86VideoAdaptorPtr adapt;
1249,1258c1248,1252
<   /* Here should be a check if the chip's ZV port is connected */
< 
<   /* A if statement of type 
<    *
<      if ( (pATI->Chip >= ATI_CHIP_XX1) & (pATI->Chip <= ATI_CHIP_XX2) )  {
<        pPriv->zv_port = TRUE;
<        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling ZV port\n");
<      }
<    *
<    would be better than the switch method below! */
---
>     if(pATI->adaptor!=NULL){
>     	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reinitializing Xvideo subsystems\n");
>     	ATIResetVideo(pScrn);
>     	return pATI->adaptor;
> 	}
1260c1254,1260
<   switch (pATI->Chip) {
---
>     if(!(adapt = ATIAllocAdaptor(pScrn)))
> 	return NULL;
> 	
>     if(pATI->Chip < ATI_CHIP_264VTB) return NULL;
>     if(pATI->Chip > ATI_CHIP_Mach64) return NULL;
>    	
>     pPriv = (ATIPortPrivPtr)(adapt->pPortPrivates[0].ptr);
1262,1266c1262,1264
<   case ATI_CHIP_264LTPRO:
<     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ATI Chip 264 LT PRO\n");    
<     pPriv->zv_port = TRUE;
<     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling ZV port\n");
<     break;
---
>     ATIReadMM_TABLE(pScrn, pPriv);
> 
>     ATIInitI2C(pScrn,pPriv);
1268,1272c1266,1305
<   case ATI_CHIP_MOBILITY:
<     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ATI Chip Mobility\n");    
<     pPriv->zv_port = TRUE;
<     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling ZV port\n");
<     break;
---
>        adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
>        adapt->name = "ATI mach64 Video Overlay";
>        if(pPriv->bt829 != NULL)
>        {
>           adapt->type = XvWindowMask | XvInputMask | XvImageMask | XvVideoMask;
>           adapt->nEncodings = 13;
> 	  if(pATI->Chip >= ATI_CHIP_264GTPRO)
> 	  	adapt->pEncodings = RagePro_InputVideoEncodings;
> 		else
> 	  	adapt->pEncodings = VT_GT_InputVideoEncodings;
>        } else
>        {
>           adapt->type = XvWindowMask | XvInputMask | XvImageMask;
>           adapt->nEncodings = 1;
>           adapt->pEncodings =  &DummyEncoding;
>        }
>        adapt->nFormats = NUM_FORMATS;
>        adapt->pFormats = Formats;
>        adapt->nPorts = 1;
>        if(pPriv->MM_TABLE_valid && (pATI->Chip == ATI_CHIP_264GTDVD))
>        {
>        	  adapt->nAttributes = NUM_ATTRIBUTES-1;
> 	  adapt->pAttributes = AIWClassicAttributes;
>        } else
>        {
>           adapt->nAttributes = NUM_ATTRIBUTES;
>           adapt->pAttributes = Attributes;
>        }
>        adapt->nImages = NUM_IMAGES;
>        adapt->pImages = Images;
>        adapt->PutVideo = ATIPutVideo;
>        adapt->PutStill = NULL;
>        adapt->GetVideo = NULL;
>        adapt->GetStill = NULL;
>        adapt->StopVideo = ATIStopVideo;
>        adapt->SetPortAttribute = ATISetPortAttribute;
>        adapt->GetPortAttribute = ATIGetPortAttribute;
>        adapt->QueryBestSize = ATIQueryBestSize;
>        adapt->PutImage = ATIPutImage;
>        adapt->QueryImageAttributes = ATIQueryImageAttributes;
1274,1278d1306
<   default:
<     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No ZV capable chip found\n");
<     break;
<   }
< }
1280,1286c1308
< static XF86VideoAdaptorPtr
< ATISetupImageVideo(ScreenPtr pScreen)
< {
<   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
<   ATIPtr pATI = ATIPTR(pScrn);
<   ATIPortPrivPtr pPriv;
<   XF86VideoAdaptorPtr adapt;
---
>     pATI->adaptor = adapt;
1288,1290c1310
<   if(pATI->adaptor!=NULL) {
<     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reinitializing Xvideo subsystems\n");
<     ATIResetVideo(pScrn);
---
>     REGION_INIT(pScreen, &(pPriv->clip), NullBox, 0);
1292,1328c1312,1317
<     return pATI->adaptor;
<   }
<   
<   if(!(adapt = ATIAllocAdaptor(pScrn)))
<     return NULL;
<   
<   if(pATI->Chip < ATI_CHIP_264VTB) return NULL;
<   if(pATI->Chip > ATI_CHIP_Mach64) return NULL;
<   
<   pPriv = (ATIPortPrivPtr)(adapt->pPortPrivates[0].ptr);
<   
<   ATIReadMM_TABLE(pScrn, pPriv);  
<   ATIInitI2C(pScrn,pPriv);
< 
<   ATICheckZV(pScrn, pATI, pPriv); /* Zoomed Video */
<   
<   adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
<   adapt->name = "ATI mach64 Video Overlay";
<   if(pPriv->bt829 != NULL || pPriv->zv_port)
<     {
<       adapt->type = XvWindowMask | XvInputMask | XvImageMask | XvVideoMask;
<       
<       if (pPriv->zv_port)
< 	adapt->nEncodings = 15;
<       else
< 	adapt->nEncodings = 13;
<       
<       if(pATI->Chip >= ATI_CHIP_264GTPRO)
< 	adapt->pEncodings = RagePro_InputVideoEncodings;
<       else
< 	adapt->pEncodings = VT_GT_InputVideoEncodings;
<     } else
<       {
< 	adapt->type = XvWindowMask | XvInputMask | XvImageMask;
< 	adapt->nEncodings = 1;
< 	adapt->pEncodings =  &DummyEncoding;
<       }
---
>     ATIResetVideo(pScrn);
>     
>     if(pATI->VBIOS!=NULL){
>     	xfree(pATI->VBIOS);
> 	pATI->VBIOS=NULL;
>     	}
1330,1367c1319
<   adapt->nFormats = NUM_FORMATS;
<   adapt->pFormats = Formats;
<   adapt->nPorts = 1;
<   if(pPriv->MM_TABLE_valid && (pATI->Chip == ATI_CHIP_264GTDVD))
<     {
<       adapt->nAttributes = NUM_ATTRIBUTES-1;
<       adapt->pAttributes = AIWClassicAttributes;
<     } else
<       {
< 	adapt->nAttributes = NUM_ATTRIBUTES;
< 	adapt->pAttributes = Attributes;
<       }
<   adapt->nImages = NUM_IMAGES;
<   adapt->pImages = Images;
<   adapt->PutVideo = ATIPutVideo;
<   adapt->PutStill = NULL;
<   adapt->GetVideo = NULL;
<   adapt->GetStill = NULL;
<   adapt->StopVideo = ATIStopVideo;
<   adapt->SetPortAttribute = ATISetPortAttribute;
<   adapt->GetPortAttribute = ATIGetPortAttribute;
<   adapt->QueryBestSize = ATIQueryBestSize;
<   adapt->PutImage = ATIPutImage;
<   adapt->QueryImageAttributes = ATIQueryImageAttributes;
<   
<   
<   pATI->adaptor = adapt;
<   
<   REGION_INIT(pScreen, &(pPriv->clip), NullBox, 0);
<   
<   ATIResetVideo(pScrn);
<   
<   if(pATI->VBIOS!=NULL){
<     xfree(pATI->VBIOS);
<     pATI->VBIOS=NULL;
<   }
<   
<   return adapt;
---
>     return adapt;
2167,2221c2119,2173
<   xf86_MSP3430SetVolume(pPriv->msp3430, MSP3430_FAST_MUTE);
<   switch(pPriv->encoding){
<   case 1:
<     pPriv->msp3430->standard = MSP3430_PAL;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
<     break;
<   case 2:
<     pPriv->msp3430->standard = MSP3430_PAL;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
<     break;
<   case 3:
<     pPriv->msp3430->standard = MSP3430_PAL;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
<     break;
<   case 4:
<     pPriv->msp3430->standard = MSP3430_NTSC;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
<     break;
<   case 5:
<     pPriv->msp3430->standard = MSP3430_NTSC;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
<     break;
<   case 6:
<     pPriv->msp3430->standard = MSP3430_NTSC;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
<     break;
<   case 7:
<     pPriv->msp3430->standard = MSP3430_SECAM;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
<     break;
<   case 8:
<     pPriv->msp3430->standard = MSP3430_SECAM;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
<     break;
<   case 9:
<     pPriv->msp3430->standard = MSP3430_SECAM;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
<     break;
<   case 10:
<     pPriv->msp3430->standard = MSP3430_SECAM;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
<     break;
<   case 11:
<     pPriv->msp3430->standard = MSP3430_SECAM;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
<     break;
<   case 12:
<     pPriv->msp3430->standard = MSP3430_SECAM;
<     pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
<     break;
<   default:
<     return;
<   }	
<   xf86_InitMSP3430(pPriv->msp3430);
<   xf86_MSP3430SetVolume(pPriv->msp3430, pPriv->mute ? MSP3430_FAST_MUTE : pPriv->volume);
---
> xf86_MSP3430SetVolume(pPriv->msp3430, MSP3430_FAST_MUTE);
> switch(pPriv->encoding){
> 	case 1:
> 		pPriv->msp3430->standard = MSP3430_PAL;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
> 		break;
> 	case 2:
> 		pPriv->msp3430->standard = MSP3430_PAL;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
> 		break;
> 	case 3:
> 		pPriv->msp3430->standard = MSP3430_PAL;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
> 		break;
> 	case 4:
> 		pPriv->msp3430->standard = MSP3430_NTSC;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
> 		break;
> 	case 5:
> 		pPriv->msp3430->standard = MSP3430_NTSC;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
> 		break;
> 	case 6:
> 		pPriv->msp3430->standard = MSP3430_NTSC;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
> 		break;
> 	case 7:
> 		pPriv->msp3430->standard = MSP3430_SECAM;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
> 		break;
> 	case 8:
> 		pPriv->msp3430->standard = MSP3430_SECAM;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
> 		break;
> 	case 9:
> 		pPriv->msp3430->standard = MSP3430_SECAM;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
> 		break;
> 	case 10:
> 		pPriv->msp3430->standard = MSP3430_SECAM;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
> 		break;
> 	case 11:
> 		pPriv->msp3430->standard = MSP3430_SECAM;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
> 		break;
> 	case 12:
> 		pPriv->msp3430->standard = MSP3430_SECAM;
> 		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
> 		break;
> 	default:
> 		return;
> 	}	
> xf86_InitMSP3430(pPriv->msp3430);
> xf86_MSP3430SetVolume(pPriv->msp3430, pPriv->mute ? MSP3430_FAST_MUTE : pPriv->volume);
2226,2291c2178,2243
<   ATIPtr pATI = ATIPTR(pScrn);
<   int width, height;
<   switch(pPriv->encoding){
<   case 1:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
<     pPriv->v=24;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
<     break;
<   case 2:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
<     pPriv->v=24;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
<     break;
<   case 3:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
<     pPriv->v=24;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
<     break;
<   case 4:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
<     pPriv->v=23;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
<     break;
<   case 5:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
<     pPriv->v=23;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
<     break;
<   case 6:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
<     pPriv->v=23;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
<     break;
<   case 7:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
<     pPriv->v=25;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
<     break;
<   case 8:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
<     pPriv->v=25;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
<     break;
<   case 9:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
<     pPriv->v=25;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
<     break;
<   default:
<     xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
<     pPriv->v=23;
<     xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
<     return;
<   }	
<   if(pATI->Chip>=ATI_CHIP_264GTPRO){
<     width = RagePro_InputVideoEncodings[pPriv->encoding].width;
<     height = RagePro_InputVideoEncodings[pPriv->encoding].height; 
<   } else {
<     width = VT_GT_InputVideoEncodings[pPriv->encoding].width;
<     height = VT_GT_InputVideoEncodings[pPriv->encoding].height; 
<   }
<   xf86_bt829_SetCaptSize(pPriv->bt829, width, height*2);
<   if(pPriv->tda9850!=NULL){
<     pPriv->tda9850->mux = pPriv->bt829->mux;
<     xf86_tda9850_setaudio(pPriv->tda9850);
<   }
---
> ATIPtr pATI = ATIPTR(pScrn);
> int width, height;
> switch(pPriv->encoding){
> 	case 1:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
> 		pPriv->v=24;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
> 		break;
> 	case 2:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
> 		pPriv->v=24;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
> 		break;
> 	case 3:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
> 		pPriv->v=24;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
> 		break;
> 	case 4:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
> 		pPriv->v=23;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
> 		break;
> 	case 5:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
> 		pPriv->v=23;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
> 		break;
> 	case 6:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
> 		pPriv->v=23;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
> 		break;
> 	case 7:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
> 		pPriv->v=25;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
> 		break;
> 	case 8:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
> 		pPriv->v=25;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
> 		break;
> 	case 9:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
> 		pPriv->v=25;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
> 		break;
> 	default:
>                 xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
> 		pPriv->v=23;
> 	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
> 		return;
> 	}	
> if(pATI->Chip>=ATI_CHIP_264GTPRO){
> 	      width = RagePro_InputVideoEncodings[pPriv->encoding].width;
>       	      height = RagePro_InputVideoEncodings[pPriv->encoding].height; 
> 	      } else {
> 	      width = VT_GT_InputVideoEncodings[pPriv->encoding].width;
>       	      height = VT_GT_InputVideoEncodings[pPriv->encoding].height; 
> 	      }
> xf86_bt829_SetCaptSize(pPriv->bt829, width, height*2);
> if(pPriv->tda9850!=NULL){
> 	pPriv->tda9850->mux = pPriv->bt829->mux;
> 	xf86_tda9850_setaudio(pPriv->tda9850);
> 	}
2306,2307c2258,2259
<   #define ENABLE_ATI_CAPTURE_WEAVE (0x1C000005L | (BUF_MODE_SINGLE <<7) | (BUF_TYPE_FRAME << 4) |  (0) | (1<<29))
<   #define ENABLE_ATI_CAPTURE_BOB (0x1C000005L | (BUF_MODE_SINGLE <<7) | (BUF_TYPE_ALTERNATING << 4) | (0) | (0<<15) | (1<<29))
---
> #define ENABLE_ATI_CAPTURE_WEAVE (0x1C000005L | (BUF_MODE_SINGLE <<7) | (BUF_TYPE_FRAME << 4) |  (0) | (1<<29))
> #define ENABLE_ATI_CAPTURE_BOB (0x1C000005L | (BUF_MODE_SINGLE <<7) | (BUF_TYPE_ALTERNATING << 4) | (0) | (0<<15) | (1<<29))
2311a2264
> 
2314,2363c2267,2316
< 	    ScrnInfoPtr pScrn,
< 	    short src_x, short src_y,
< 	    short drw_x, short drw_y,
< 	    short src_w, short src_h,
< 	    short drw_w, short drw_h,
< 	    RegionPtr clipBoxes, pointer data
< 	    ){
<   ATIPtr pATI = ATIPTR(pScrn);
<   ATIPortPrivPtr pPriv = (ATIPortPrivPtr)data;
<   INT32 xa, xb, ya, yb, top;
<   int pitch, new_size, offset1, offset2, s2offset, s3offset;
<   int srcPitch, srcPitch2, dstPitch;
<   int bpp;
<   BoxRec dstBox;
<   CARD32 id;
<   int width, height;
< 
<   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PutVideo\n");
<   /*
<    * s2offset, s3offset - byte offsets into U and V plane of the
<    *                      source where copying starts.  Y plane is
<    *                      done by editing "buf".
<    *
<    * offset - byte offset to the first line of the destination.
<    *
<    * dst_start - byte address to the first displayed pel.
<    *
<    */
<   
<   /* make the compiler happy */
<   s2offset = s3offset = srcPitch2 = 0;
<   
<   if(src_w > (drw_w << 4))
<     drw_w = src_w >> 4;
<   if(src_h > (drw_h << 4))
<     drw_h = src_h >> 4;
<   
<   /* Clip */
<   xa = src_x;
<   xb = src_x + src_w;
<   ya = src_y;
<   yb = src_y + src_h;
<   
<   dstBox.x1 = drw_x;
<   dstBox.x2 = drw_x + drw_w;
<   dstBox.y1 = drw_y;
<   dstBox.y2 = drw_y + drw_h;
<   
<   if(pPriv->bt829 != NULL || pPriv->zv_port)
<     {
---
>   ScrnInfoPtr pScrn,
>   short src_x, short src_y,
>   short drw_x, short drw_y,
>   short src_w, short src_h,
>   short drw_w, short drw_h,
>   RegionPtr clipBoxes, pointer data
> ){
>    ATIPtr pATI = ATIPTR(pScrn);
>    ATIPortPrivPtr pPriv = (ATIPortPrivPtr)data;
>    INT32 xa, xb, ya, yb, top;
>    int pitch, new_size, offset1, offset2, s2offset, s3offset;
>    int srcPitch, srcPitch2, dstPitch;
>    int bpp;
>    BoxRec dstBox;
>    CARD32 id;
>    int width, height;
> 
>    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PutVideo\n");
>    /*
>     * s2offset, s3offset - byte offsets into U and V plane of the
>     *                      source where copying starts.  Y plane is
>     *                      done by editing "buf".
>     *
>     * offset - byte offset to the first line of the destination.
>     *
>     * dst_start - byte address to the first displayed pel.
>     *
>     */
> 
>    /* make the compiler happy */
>    s2offset = s3offset = srcPitch2 = 0;
> 
>    if(src_w > (drw_w << 4))
> 	drw_w = src_w >> 4;
>    if(src_h > (drw_h << 4))
> 	drw_h = src_h >> 4;
> 
>    /* Clip */
>    xa = src_x;
>    xb = src_x + src_w;
>    ya = src_y;
>    yb = src_y + src_h;
> 
>    dstBox.x1 = drw_x;
>    dstBox.x2 = drw_x + drw_w;
>    dstBox.y1 = drw_y;
>    dstBox.y2 = drw_y + drw_h;
> 
>    if(pPriv->bt829 != NULL)
>    {
2365,2371c2318,2324
< 	width = RagePro_InputVideoEncodings[pPriv->encoding].width;
< 	height = RagePro_InputVideoEncodings[pPriv->encoding].height; 
<       } else {
< 	width = VT_GT_InputVideoEncodings[pPriv->encoding].width;
< 	height = VT_GT_InputVideoEncodings[pPriv->encoding].height; 
<       }
<     } else 
---
> 	      width = RagePro_InputVideoEncodings[pPriv->encoding].width;
>       	      height = RagePro_InputVideoEncodings[pPriv->encoding].height; 
> 	      } else {
> 	      width = VT_GT_InputVideoEncodings[pPriv->encoding].width;
>       	      height = VT_GT_InputVideoEncodings[pPriv->encoding].height; 
> 	      }
>    } else 
2373,2376c2326,2423
<   
<   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PutVideo %d %d\n", width,height);
<   
<   if(!ATIClipVideo(&dstBox, &xa, &xb, &ya, &yb, clipBoxes, width, height))
---
>         
>    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PutVideo %d %d\n", width,height);
> 
>    if(!ATIClipVideo(&dstBox, &xa, &xb, &ya, &yb, clipBoxes, width, height))
> 	return Success;
> 
>    dstBox.x1 -= pScrn->frameX0;
>    dstBox.x2 -= pScrn->frameX0;
>    dstBox.y1 -= pScrn->frameY0;
>    dstBox.y2 -= pScrn->frameY0;
> 
>    bpp = pScrn->bitsPerPixel >> 3;
>    pitch = bpp * pScrn->displayWidth;
> 
>    id = FOURCC_YUY2;
>    
>    top = ya>>16;
> 
>    switch(id) {
>    case FOURCC_YV12:
>    case FOURCC_I420:
>    	top &= ~1;
> 	dstPitch = ((width << 1) + 15) & ~15;
> 	new_size = ((dstPitch * height) + bpp - 1) / bpp;
> 	srcPitch = (width + 3) & ~3;
> 	s2offset = srcPitch * height;
> 	srcPitch2 = ((width >> 1) + 3) & ~3;
> 	s3offset = (srcPitch2 * (height >> 1)) + s2offset;
> 	break;
>    case FOURCC_UYVY:
>    case FOURCC_YUY2:
>    default:
> 	dstPitch = ((width << 1) + 15) & ~15;
> 	new_size = ((dstPitch * height) + bpp - 1) / bpp;
> 	srcPitch = (width << 1);
> 	break;
>    }
> 
>    new_size += 0x1f;  /* for aligning */
> 
>    if(!(pPriv->linear = ATIAllocateMemory(pScrn, pPriv->linear, new_size*2)))
>    {
> 	return BadAlloc;
>    }
> 
> 
>    offset1 = (pPriv->linear->offset*bpp+0xf) & (~0xf);
>    offset2 = ((pPriv->linear->offset+new_size)*bpp + 0x1f) & (~0xf);
>    
>    ATIMach64WaitForFIFO(pATI, 9); 
>    outf(CAPTURE_BUF0_OFFSET, offset1);
> /*   outf(BUF0_CAP_ODD_OFFSET, 0); */
>    outf(ONESHOT_BUF_OFFSET, offset1);
>    outf(CAPTURE_BUF1_OFFSET, offset2);
> /*   outf(BUF1_CAP_ODD_OFFSET, 0); */
>    
>    outf(CAPTURE_X_WIDTH, (width*2)<<16);
>    outf(CAPTURE_START_END, (((height)+pPriv->v-1)<<16)|(pPriv->v));
>    outf(CAPTURE_CONFIG, ENABLE_ATI_CAPTURE_DOUBLEBUF);
>    outf(CAPTURE_DEBUG, 0);
>    
>    outf(OVERLAY_TEST, 0);
>    
>    /* activate capture unit */
>    outf(TRIG_CNTL, (1<<31) | 1);
>    
>    if(! pPriv->video_stream_active){
>       
>    if(pPriv->bt829 != NULL) 
>    {
>       ATI_BT_SetEncoding(pScrn, pPriv);
>       xf86_bt829_SetCaptSize(pPriv->bt829, width, height*2);
>    }
>    
>    if(pPriv->i2c!=NULL) ATI_board_setmisc(pPriv);
> 
>    if(pPriv->msp3430 != NULL) ATI_MSP_SetEncoding(pPriv);
>    ATIMuteAudio(pPriv, pPriv->mute);
>    }
> 
>     /* update cliplist */
>     if(!RegionsEqual(&pPriv->clip, clipBoxes)) {
> 	REGION_COPY(pScreen, &pPriv->clip, clipBoxes);
> 	/* draw these */
> 	if(pPriv->autopaint_colorkey)(*pATI->pXAAInfo->FillSolidRects)(pScrn, pPriv->colorKey, GXcopy, ~0,
> 					REGION_NUM_RECTS(clipBoxes),
> 					REGION_RECTS(clipBoxes));
>     }
> 
>     pPriv->doubleBuffer = 1;
>     ATIDisplayVideo(pScrn, pPriv, id, offset1 +top*srcPitch, offset2+top*srcPitch, width, height, width,
> 		     xa, xb, ya, &dstBox, src_w, src_h, drw_w, drw_h);
> 
>     pPriv->video_status = CLIENT_VIDEO_ON;
>     pPriv->video_stream_active = TRUE;
> 
>     pATI->VideoTimerCallback = ATIVideoTimerCallback;
> 
2378,2474d2424
<   
<   dstBox.x1 -= pScrn->frameX0;
<   dstBox.x2 -= pScrn->frameX0;
<   dstBox.y1 -= pScrn->frameY0;
<   dstBox.y2 -= pScrn->frameY0;
<   
<   bpp = pScrn->bitsPerPixel >> 3;
<   pitch = bpp * pScrn->displayWidth;
<   
<   id = FOURCC_YUY2;
<   
<   top = ya>>16;
<   
<   switch(id) {
<   case FOURCC_YV12:
<   case FOURCC_I420:
<     top &= ~1;
<     dstPitch = ((width << 1) + 15) & ~15;
<     new_size = ((dstPitch * height) + bpp - 1) / bpp;
<     srcPitch = (width + 3) & ~3;
<     s2offset = srcPitch * height;
<     srcPitch2 = ((width >> 1) + 3) & ~3;
<     s3offset = (srcPitch2 * (height >> 1)) + s2offset;
<     break;
<   case FOURCC_UYVY:
<   case FOURCC_YUY2:
<   default:
<     dstPitch = ((width << 1) + 15) & ~15;
<     new_size = ((dstPitch * height) + bpp - 1) / bpp;
<     srcPitch = (width << 1);
<     break;
<   }
<   
<   new_size += 0x1f;  /* for aligning */
<   
<   if(!(pPriv->linear = ATIAllocateMemory(pScrn, pPriv->linear, new_size*2)))
<     {
<       return BadAlloc;
<     }
<   
<   offset1 = (pPriv->linear->offset*bpp+0xf) & (~0xf);
<   offset2 = ((pPriv->linear->offset+new_size)*bpp + 0x1f) & (~0xf);
<   
<   ATIMach64WaitForFIFO(pATI, 9); 
<   outf(CAPTURE_BUF0_OFFSET, offset1);
<   /*   outf(BUF0_CAP_ODD_OFFSET, 0); */
<   outf(ONESHOT_BUF_OFFSET, offset1);
<   outf(CAPTURE_BUF1_OFFSET, offset2);
<   /*   outf(BUF1_CAP_ODD_OFFSET, 0); */
<   
<   outf(CAPTURE_X_WIDTH, (width*2)<<16);
<   outf(CAPTURE_START_END, (((height)+pPriv->v-1)<<16)|(pPriv->v));
<   if (pPriv->zv_port) 
<     outf(CAPTURE_CONFIG, ENABLE_ATI_CAPTURE_DOUBLEBUF | ZV_ENABLE); /* Switch on Zoomed Video (ZV) */
<   else
<     outf(CAPTURE_CONFIG, ENABLE_ATI_CAPTURE_DOUBLEBUF);
<   
<   outf(CAPTURE_DEBUG, 0);
<   
<   outf(OVERLAY_TEST, 0);
<   
<   /* activate capture unit */
<   outf(TRIG_CNTL, (1<<31) | 1);
<   
<   if(! pPriv->video_stream_active){
<     
<     if(pPriv->bt829 != NULL) 
<       {
< 	ATI_BT_SetEncoding(pScrn, pPriv);
< 	xf86_bt829_SetCaptSize(pPriv->bt829, width, height*2);
<       }
<     
<     if(pPriv->i2c!=NULL) ATI_board_setmisc(pPriv);
<     
<     if(pPriv->msp3430 != NULL) ATI_MSP_SetEncoding(pPriv);
<     ATIMuteAudio(pPriv, pPriv->mute);
<   }
<   
<   /* update cliplist */
<   if(!RegionsEqual(&pPriv->clip, clipBoxes)) {
<     REGION_COPY(pScreen, &pPriv->clip, clipBoxes);
<     /* draw these */
<     if(pPriv->autopaint_colorkey)(*pATI->pXAAInfo->FillSolidRects)(pScrn, pPriv->colorKey, GXcopy, ~0,
< 								   REGION_NUM_RECTS(clipBoxes),
< 								   REGION_RECTS(clipBoxes));
<   }
<   
<   pPriv->doubleBuffer = 1;
<   ATIDisplayVideo(pScrn, pPriv, id, offset1 +top*srcPitch, offset2+top*srcPitch, width, height, width,
< 		  xa, xb, ya, &dstBox, src_w, src_h, drw_w, drw_h);
<   
<   pPriv->video_status = CLIENT_VIDEO_ON;
<   pPriv->video_stream_active = TRUE;
<   
<   pATI->VideoTimerCallback = ATIVideoTimerCallback;
<   
<   return Success;
2480,2495c2430,2449
<   ATIPtr pATI = ATIPTR(pScrn);
<   ATIPortPrivPtr pPriv = pATI->adaptor->pPortPrivates[0].ptr;
<   
<   if(pPriv->video_status & TIMER_MASK) {
<     if(pPriv->video_status & OFF_TIMER) {
<       if(pPriv->offTime < time) {
< 	ATIMach64WaitForFIFO(pATI, 2); 
< 	outf(OVERLAY_SCALE_CNTL, 0x80000000);
< 	pPriv->video_status = FREE_TIMER;
< 	pPriv->freeTime = time + FREE_DELAY;
<       }
<     } else {  /* FREE_TIMER */
<       if(pPriv->freeTime < time) {
< 	if(pPriv->linear) {
< 	  xf86FreeOffscreenLinear(pPriv->linear);
< 	  pPriv->linear = NULL;
---
>     ATIPtr pATI = ATIPTR(pScrn);
>     ATIPortPrivPtr pPriv = pATI->adaptor->pPortPrivates[0].ptr;
> 
>     if(pPriv->video_status & TIMER_MASK) {
> 	if(pPriv->video_status & OFF_TIMER) {
> 	    if(pPriv->offTime < time) {
> 		ATIMach64WaitForFIFO(pATI, 2); 
> 		outf(OVERLAY_SCALE_CNTL, 0x80000000);
> 		pPriv->video_status = FREE_TIMER;
> 		pPriv->freeTime = time + FREE_DELAY;
> 	    }
> 	} else {  /* FREE_TIMER */
> 	    if(pPriv->freeTime < time) {
> 		if(pPriv->linear) {
> 		   xf86FreeOffscreenLinear(pPriv->linear);
> 		   pPriv->linear = NULL;
> 		}
> 		pPriv->video_status = 0;
> 		pATI->VideoTimerCallback = NULL;
> 	    }
2497c2451
< 	pPriv->video_status = 0;
---
>     } else  /* shouldn't get here */
2499,2502d2452
<       }
<     }
<   } else  /* shouldn't get here */
<     pATI->VideoTimerCallback = NULL;
