1. 关于音频设置：
		通道是否需要选择。先认为但麦克风是单通道，故通道固定为1
		采样率和采样位数是否需要选择？
		
2. 音频缓冲区：
	当缓冲数组满时，新来的数据是替换掉开始部分还是等缓冲数组数据都被处理（采集为训练样本）完。先执行第一种。

ui->customPlot->graph(0)->setData(x, y0);


一. 线程同步

	两个线程共享同一块资源，当线程A对资源写操作过程中失去cpu, cpu运行B线程重新对这块资源进行写操作，就会把A对资源做的修改覆盖掉，
	之后线程A重新获得cpu时继续从上次的资源位置写操作，造成数据混乱。

	实现线程同步是通过加锁来实现的。首先创建锁对象并与使用锁的线程关联，在每个线程的线程函数中开始时候加锁，执行完的时候解锁。
	其他线程在访问共享变量时都要先判断锁是否在开启状态，如果是关的及时获得cpu也不能访问共享资源而回到原来的线程。另外，加锁程序所占的线程函数总程序的比例应该越小越好，
	让cpu能在运行没被锁住的程序切换到其他线程，让多个线程交替运行。如果把线程函数全部锁住就会出现，这个线程集中运行一段时间，在线程函数结束的瞬间切换到另一个线程在集中运行一段时间。

	主要线程函数：
	pthread_init(pid, func) : pid是线程对象的地址，func是给线程指定的线程函数。
	pthread_join(pid): 这个函数调用是吧pid线程加入到当前线程中来，等待子线程的线程函数执行完后才结束当前线程。
	pthread_mutex_lock():这是一个阻塞函数，是对当前线程进行加锁，但是加锁前会先判断锁的状态，如果锁是关的当前线程会阻塞在那里等待，当锁开了后才继续执行。
	pthread_mutex_trylock() ：不是阻塞的。进行尝试加锁如果锁是关的就跳过加锁直接向下执行。对于非阻塞函数只能通过轮询方式来执行。

	run(){
		while(1)
		{
			...
			mutex_unlock();
			sleep(10);		//使cpu切换线程更容易
		}
	}
	
	 读写锁：有多个线程对同一块共享资源进行读写。linux定义了pthread_rw_mutex,有规律: 写独占，读共享，写锁优先级高。写线程要独占资源，读线程可以共享资源，当多个线程同时要对资源加锁时，
	 优先写线程。
			
	